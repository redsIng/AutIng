<TeXmacs|1.99.20>

<style|<tuple|generic|italian>>

<\body>
  \;

  <\table-of-contents|toc>
    <vspace*|1fn><with|font-series|bold|math-font-series|bold|Descrivere
    brevemente l'equazione di Hamilton-Jacaobi Bellman. Dimostrare che HJB
    fornisce condizioni necessarie di ottimalità.>
    <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
    <no-break><pageref|auto-1><vspace|0.5fn>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|Discutere
    l'equazione differenziale di Riccati e dimostrare che la soluzione
    <with|mode|math|P<around*|(|t|)>> esiste per ogni
    <with|mode|math|t\<in\><around*|[|0,T|]>>>
    <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
    <no-break><pageref|auto-2><vspace|0.5fn>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|<with|font-series|bold|Enunciare
    il teorema di essitenza della soluzione del LQR ad orizzonte infinito.
    Dimostrare inoltre che la sequenza di soluzioni
    <with|mode|math|P<rsub|T><around*|(|t|)>> del problema ad orizzone finito
    ha un limite per <with|mode|math|T\<rightarrow\>\<infty\>>.>>
    <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
    <no-break><pageref|auto-3><vspace|0.5fn>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|<with|font-series|bold|Enunciare
    il teorema di esistenza della soluzione del LQR ad orizzonte infinito.
    Dimostrare che il sistema a ciclo chiuso con la soluzione di LQR risulta
    asintoticamente stabile.>> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
    <no-break><pageref|auto-4><vspace|0.5fn>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|<with|font-series|bold|Enunciare
    e dimostrare il Principio di Ottimalità>.>
    <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
    <no-break><pageref|auto-5><vspace|0.5fn>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|<with|font-series|bold|Discutere
    il problema del Tracking e della reiezione di disturbi noti.>>
    <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
    <no-break><pageref|auto-6><vspace|0.5fn>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|Dimostrare che
    l'equazione di Hamilton Jacobi Bellman fornisce condizioni sufficienti di
    ottimalità.> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
    <no-break><pageref|auto-7><vspace|0.5fn>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|Dare
    definizione di Value Iteration> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
    <no-break><pageref|auto-8><vspace|0.5fn>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|Dare
    definizione di Policy Improvement> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
    <no-break><pageref|auto-9><vspace|0.5fn>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|Dare
    definizione di Policy Evaluation> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
    <no-break><pageref|auto-10><vspace|0.5fn>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|Dare
    definizione di Funzione Valore in un contesto di Reinforcement Learning>
    <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
    <no-break><pageref|auto-11><vspace|0.5fn>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|Dare
    definizione di Funzione Qualità> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
    <no-break><pageref|auto-12><vspace|0.5fn>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|Discutere di
    MPC e dimostrare la ammissibilità,stabilità.>
    <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
    <no-break><pageref|auto-13><vspace|0.5fn>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|<with|font-series|bold|Enunciare
    il teorema di essitenza della soluzione del LQR ad orizzonte infinito.
    L'unicità della soluzione stabilizzante di ARE.>>
    <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
    <no-break><pageref|auto-14><vspace|0.5fn>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|Principio
    Ottimalità (Programmazione Quadratica)>
    <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
    <no-break><pageref|auto-15><vspace|0.5fn>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|Equazione di
    Bellman e Soluzione ricorsia di Bellman>
    <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
    <no-break><pageref|auto-16><vspace|0.5fn>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|Processo
    Decisionale di Markov Stocastico> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
    <no-break><pageref|auto-17><vspace|0.5fn>

    <vspace*|1fn><with|font-series|bold|math-font-series|bold|Discutere
    l'equazione differenziale di Riccati e dimostrare esistenza soluzione
    tramite matrice Hamiltoniana> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
    <no-break><pageref|auto-18><vspace|0.5fn>
  </table-of-contents>

  <section*|Descrivere brevemente l'equazione di Hamilton-Jacaobi Bellman.
  Dimostrare che HJB fornisce condizioni necessarie di ottimalità.>

  <\answer*>
    L'equazione di Hamilton Jacobi Bellman è:

    <\equation*>
      <choice|<tformat|<table|<row|<cell|-<frac|\<partial\>V|\<partial\>t><rsup|\<ast\>><around*|(|x<around*|(|t|)>,t|)>=min<rsub|u<around*|(|t|)>><around*|{|l<around*|(|x<around*|(|t|)>,u<around*|(|t|)>,t|)>+<frac|\<partial\>V|\<partial\>x><rsup|\<ast\>><around*|(|x<around*|(|t|)>,t|)>*f<around*|(|x<around*|(|t|)>,u<around*|(|t|)>,t|)>|}>>>|<row|<cell|V<rsup|\<ast\>><around*|(|x,T|)>=m<around*|(|x|)>>>>>><space|1em>\<forall\>x\<in\>\<bbb-R\><rsup|n>,t\<in\><around*|[|t<rsub|0>,T|]>
    </equation*>

    Permette di rappresentare la funzione valore ottima di un problema di
    controllo ottimo di Bolza:

    <\equation*>
      <choice|<tformat|<table|<row|<cell|min<rsub|u>J<around*|(|u|)>=min<rsub|u><around*|{|<big|int><rsub|t<rsub|0>><rsup|T>l<around*|(|x<around*|(|\<tau\>|)>,u<around*|(|\<tau\>|)>,\<tau\>|)>d\<tau\>+m<around*|(|x<around*|(|T|)>|)>|}>>>|<row|<cell|<wide|x|\<dot\>>=f<around*|(|x,u,t|)>>>|<row|<cell|x<around*|(|t<rsub|0>|)>=x<rsub|0>>>>>>
    </equation*>

    Generalmente questa equazione non è lineare e la sua soluzione è proprio
    la funzione valore ottima che rispetta l'equazioene di Hellman del
    problema dato e, quindi, rappresentante le decisioni ottime da effettuare
    partendo da un determinato stato e tempo iniziale. In particolare,
    l'equazione HJB fornisce condizioni necessarie di ottimalità. A tale
    scopo definiamo la funzione valore per il problema di Bolza:

    <\equation*>
      V<rsup|\<ast\>><around*|(|x<around*|(|t|)>,t|)>=min<rsub|u<around*|(|\<tau\>|)>,\<tau\>\<in\><around*|[|\<tau\>.T|]>><around*|{|<big|int><rsub|t><rsup|T>l<around*|(|x<around*|(|s|)>,u<around*|(|s|)>,s|)>d
      s+m<around*|(|x<around*|(|T|)>|)>|}>
    </equation*>

    <\equation*>
      =min<rsub|u<around*|(|\<tau\>|)>,\<tau\>\<in\><around*|[|t,T|]>><around*|{|<big|int><rsub|t><rsup|t+\<Delta\>t>l<around*|(|x<around*|(|s|)>,u<around*|(|s|)>,s|)>d
      s+<big|int><rsub|t+\<Delta\>t><rsup|T>l<around*|(|x<around*|(|s|)>,u<around*|(|s|)>,s|)>d
      s+m<around*|(|x<around*|(|T|)>|)>|}>
    </equation*>

    <\equation*>
      =min<rsub|u<around*|(|\<tau\>|)>,\<tau\>\<in\><around*|[|t,T|]>><around*|{|<big|int><rsub|t><rsup|t+\<Delta\>t>l<around*|(|x<around*|(|s|)>,u<around*|(|s|)>,s|)>d
      s+V<rsup|\<ast\>><around*|(|x<around*|(|t+\<Delta\>t|)>,t+\<Delta\>t|)>|}>
    </equation*>

    Da questa espressione ricaviamo la sua corrispondente espressione
    differenziale sviluppando al primo ordine la funzione valore:

    <\equation*>
      <choice|<tformat|<table|<row|<cell|0=min<rsub|u<around*|(|t|)>><around*|{|l<around*|(|x<around*|(|t|)>,u<around*|(|t|)>,t|)>+-<frac|\<partial\>V|\<partial\>t><rsup|\<ast\>><around*|(|x<around*|(|t|)>,t|)>+<frac|\<partial\>V|\<partial\>x><rsup|\<ast\>><around*|(|x<around*|(|t|)>,t|)>*f<around*|(|x<around*|(|t|)>,u<around*|(|t|)>,t|)>|}>>>|<row|<cell|V<rsup|\<ast\>><around*|(|x,T|)>=m<around*|(|x|)>>>>>><space|1em>\<forall\>x\<in\>\<bbb-R\><rsup|n>,t\<in\><around*|[|t<rsub|0>,T|]>
    </equation*>

    Dato che dobbiamo determinare la soluzione per ogni istante di tempo e
    per ogni stato, si ottiene l'equazione HJB:

    <\equation*>
      <choice|<tformat|<table|<row|<cell|-<frac|\<partial\>V|\<partial\>t><rsup|\<ast\>><around*|(|x<around*|(|t|)>,t|)>=min<rsub|u<around*|(|t|)>><around*|{|l<around*|(|x<around*|(|t|)>,u<around*|(|t|)>,t|)>+<frac|\<partial\>V|\<partial\>x><rsup|\<ast\>><around*|(|x<around*|(|t|)>,t|)>*f<around*|(|x<around*|(|t|)>,u<around*|(|t|)>,t|)>|}>>>|<row|<cell|V<rsup|\<ast\>><around*|(|x,T|)>=m<around*|(|x|)>>>>>><space|1em>\<forall\>x\<in\>\<bbb-R\><rsup|n>,t\<in\><around*|[|t<rsub|0>,T|]>
    </equation*>
  </answer*>

  \;

  \;

  \;

  \;

  <section*|Discutere l'equazione differenziale di Riccati e dimostrare che
  la soluzione <math|P<around*|(|t|)>> esiste per ogni
  <math|t\<in\><around*|[|0,T|]>>>

  <\answer*>
    Considerato un problerma di controllo ottimo su orizzone finito descritto
    da un sistema lineare ed indice di costo quadratico:

    <\equation*>
      min<rsub|u>J<around*|(|u|)>=<around*|{|<frac|1|2><big|int><rsub|0><rsup|T><around*|(|x<around*|(|t|)><rsup|T>*Q*x<around*|(|t|)>+u<around*|(|t|)><rsup|T>*R*u<around*|(|t|)>|)>d
      t|}>
    </equation*>

    <\equation*>
      <wide|x|\<dot\>><around*|(|t|)>=A*x<around*|(|t|)>+B*u<around*|(|t|)><space|1em>x<around*|(|0|)>=x<rsub|0>
    </equation*>
  </answer*>

  Il relativo costo di questo problema è il seguente:

  <\equation*>
    -<frac|1|2>x<rsup|T>*<wide|P*|\<dot\>>x=<around*|(|<frac|1|2>x<around*|(|t|)><rsup|T>*Q*x<around*|(|t|)>+x<around*|(|t|)><rsup|T>*A*x-<frac|1|2>*x<rsup|T>P<around*|(|t|)>*B*R<rsup|-1>*B<rsup|T>P<around*|(|t|)>*x|)>
  </equation*>

  Dato che questa equazione deve valere per ongi sitante di tempo e eper ogni
  stato, la matrice <math|P<around*|(|t|)>> deve soddisfare l'equazione
  differenziale di Riccati:

  <\equation*>
    -<wide|P|\<dot\>><around*|(|t|)>=P<around*|(|t|)>*A+A<rsup|T>*P<around*|(|t|)>-P<around*|(|t|)>*B*R<rsup|-1>*B<rsup|T>*P<around*|(|t|)>+Q<space|1em>P<around*|(|T|)>=M
  </equation*>

  Per dimostrare che la soluzione della DRE esiste in tutto l'intervallo
  occorre dimostrare l'esistenza locale e globale della soluzione. In
  particolare, la soluzione locale è garantita integrando all'indietro;
  inoltre per l'esisteza della soluzione globale supponiamo per assurdo che
  esista un istante <math|<wide|t|^>\<less\>T> è tale che
  <math|P<around*|(|t|)>> esiste sull'intervallo aperto
  <math|<around*|(|<wide|t|^>,T|]>> , ma un suo elemento
  <math|p<rsub|i,j><around*|(|t|)>> diventa illimitato per <math|t> che
  converge a <math|<wide|t|^>>. Si possono distinguere due casi:

  <\enumerate>
    <item>L'elemento di <math|p<rsub|i,j><around*|(|t|)>> si trova fuori
    diagonale,quindi <math|i\<neq\>j>. Si considera il minore di ordine 2
    ottenuto proprio dalle righe e colonne <math|i,j>. Ci calcoliamo il
    determinante:

    <\equation*>
      det<matrix|<tformat|<table|<row|<cell|p<rsub|i,i><around*|(|t|)>>|<cell|p<rsub|i,j><around*|(|t|)>>>|<row|<cell|p<rsub|i,j><around*|(|t|)>>|<cell|p<rsub|j,j><around*|(|t|)>>>>>>=p<rsub|i,i><around*|(|t|)>p<rsub|j,j><around*|(|t|)>-p<rsub|i,j><around*|(|t|)><rsup|2>
    </equation*>

    Il che è un assurdo poiché il minore diventa negativo per
    <math|t\<rightarrow\><wide|t|^><rsup|+>> poiché
    <math|p<rsub|i,j><around*|(|t|)>> è fuori diagonale.

    <item>L'alemnto <math|p<rsub|i,j><around*|(|t|)>> appartiene alla
    diagonale <math|i=j>. Quindi si considerimaoa la base canonica come
    condizione:

    <\equation*>
      \<eta\><rsub|i>=<around*|[|0,\<ldots\>,1,0,\<ldots\>,0|]>
    </equation*>

    Che mi seleziona l'elemento <math|p<rsub|i,i><around*|(|t|)>> all'interno
    della diagonale. Quindi scrivendo l'indice di costo:

    <\equation*>
      V<rsup|\<ast\>><around*|(|\<eta\><rsub|i>,t|)>=<frac|1|2>\<eta\><rsub|i><rsup|T>P<around*|(|t|)>*\<eta\><rsub|i>=<frac|1|2>P<rsub|i,i><around*|(|t|)>\<longrightarrow\>\<infty\>
      per t\<longrightarrow\><wide|t|^><rsup|*+>
    </equation*>

    A questo punto occorre considerare il costo ottenuto dal controllo ottimo
    che non deve essere maggiore rispetto al costo ottenuto da qualsiasi
    altro controllo, per esempio valutiamo il costo con <math|u=0>. Allora:

    <\equation*>
      u=0\<longrightarrow\><wide|x=A*x\<longrightarrow\>x<around*|(|\<tau\>|)>=e<rsup|A<around*|(|t-\<tau\>|)>>\<eta\>|\<dot\>><rsub|i>
    </equation*>

    Quindi il costo diventa:

    <\equation*>
      J<around*|(|0|)>=<frac|1|2><big|int><rsub|t><rsup|T>\<eta\><rsub|i><rsup|T>e<rsup|A<rsup|T><around*|(|t-\<tau\>|)>>Qe<rsup|A<rsup|><around*|(|t-\<tau\>|)>>\<eta\><rsub|i>d\<tau\>+<frac|1|2>\<eta\><rsub|i><rsup|T>e<rsup|A<rsup|T><around*|(|T-t|)>>M*e<rsup|A<rsup|T><around*|(|T-t|)>>\<eta\><rsub|i>\<less\>\<infty\>
    </equation*>

    per ogni t, visto che si tratta di un integrale di una funzione continua
    su un intervallo limitato e quidi abbiamo un costo limitato minore del
    costo ottimo e quindi abbiamo un assurdo.
  </enumerate>

  <section*|<with|font-series|bold|Enunciare il teorema di essitenza della
  soluzione del LQR ad orizzonte infinito. Dimostrare inoltre che la sequenza
  di soluzioni <math|P<rsub|T><around*|(|t|)>> del problema ad orizzone
  finito ha un limite per <math|T\<rightarrow\>\<infty\>>.>>

  <\answer*>
    Consideriamo il problema LQR su orizzonte finito con
    <math|M=0,R\<gtr\>0,Q=D<rsup|T>D\<gtr\>0>. Supponiamo che la coppia
    <math|<around*|(|A,D|)>> è osservabile e <math|<around*|(|A,B|)>> è
    controllabile. Allora:

    <\enumerate>
      <\itemize>
        <item>Esiste un'unica soluzione definita positiva <math|<overline|P>>
        di ARE;

        <item>Il sistema a ciclo chiuso:

        <\equation*>
          <wide|x|\<dot\>>=<around*|(|A-B*R<rsup|-1>B<rsup|T><overline|P>|)>x
        </equation*>

        ha un equilibrio in zero asintoticamente stabile.
      </itemize>
    </enumerate>

    Per dimostrare l'esistenza della soluzioni occorre definire inizialmente
    una famiglia di successioni <math|<around*|{|P<rsub|T<rsub|i>><around*|(|t|)>|}><rsub|T>>
    di soluzioni in <math|<around*|[|0,T<rsub|i>|]>> al variare di <math|i>.
    Questa famiglia di successione ha un limite per
    <math|T\<rightarrow\>\<infty\>>:

    <\enumerate>
      <\itemize>
        <item>è monoticamente non descrente;

        <item>ogni elemento è limitato superiormente;
      </itemize>
    </enumerate>

    Per il primo punto prendiamo due istanti temrinali
    <math|T<rsub|1>\<less\>T<rsub|2>>. Dalla definizione di funzione valore:

    <\equation*>
      V<rsub|1><rsup|\<ast\>><around*|(|t,x|)>=<big|int><rsub|t><rsup|T<rsub|1>>l<around*|(|x<rsub|1><around*|(|\<tau\>|)>,u<around*|(|\<tau\>|)>|)>d\<tau\>\<leqslant\><big|int><rsub|t><rsup|T<rsub|1>>l<around*|(|x<rsub|2><around*|(|\<tau\>|)>,u<rsub|2><around*|(|\<tau\>|)>|)>d\<tau\>
    </equation*>

    <\equation*>
      \<leqslant\><big|int><rsub|t><rsup|T<rsub|1>>l<around*|(|x<rsub|2><around*|(|\<tau\>|)>,u<rsub|2><around*|(|\<tau\>|)>|)>d\<tau\>+<big|int><rsub|T<rsub|1>><rsup|T<rsub|2>>l<around*|(|x<rsub|2><around*|(|\<tau\>|)>,u<rsub|2><around*|(|\<tau\>|)>|)>d\<tau\>=V<rsub|2><rsup|\<ast\>><around*|(|t,x|)>
    </equation*>

    Quindi sussiste una relazione d'ordinare del tipo:

    <\equation*>
      P<rsub|T<rsub|1>><around*|(|t|)>\<leqslant\>P<rsub|T<rsub|2>><around*|(|t|)>
    </equation*>

    Quindi <math|P<around*|(|t|)>> è monotonicamente non decrescente. A
    questo punto per dimostrare la limitatezza di ogni suo elemento facciamo
    riferimento all'ipotesi di controllabilità di <math|<around*|(|A,B|)>>.
    Quindi, esiste una matrice <math|k> t.c. <math|A+B*K> abbia tutit gli
    autovalori a parte reale negativa:

    <\equation*>
      \<sigma\><around*|(|A+B*K|)>\<subset\>\<bbb-C\><rsup|->
    </equation*>

    Il sistema a ciclo chiuso con <math|u=K*x> diventa
    <math|<wide|x|\<dot\>>=<around*|(|A+B*K|)>x\<Rightarrow\>x<around*|(|t|)>=e<rsup|<around*|(|A+B*K|)>t>x<rsub|0>>.
    Il relativo costo:

    <\equation*>
      J<around*|(|u|)>=<frac|1|2><big|int><rsub|0><rsup|T><around*|(|x<around*|(|\<tau\>|)><rsup|T>*Q*x<around*|(|\<tau\>|)>+u<around*|(|\<tau\>|)><rsup|T>*R*u<around*|(|\<tau\>|)>|)>d\<tau\>=<frac|1|2><big|int><rsub|0><rsup|T>x<around*|(|\<tau\>|)><rsup|T>*<around*|(|Q+K<rsup|T>*R*K|)>*x<around*|(|\<tau\>|)>d\<tau\>
    </equation*>

    <\equation*>
      =<frac|1|2>x<rsub|0><around*|(|<big|int><rsub|0><rsup|T>e<rsup|<around*|(|A+B*K|)><rsup|T>\<tau\>>*<around*|(|Q+K<rsup|T>*R*K|)>*e<rsup|<around*|(|A+B*K|)>>d\<tau\>|)>x<rsub|0>
    </equation*>

    Per dimostrare che è limitato dobbiamo effettuare il limite per
    <math|T\<rightarrow\>\<infty\>>, questo limite lo chiamiamo
    <math|<wide|P|^>>.Quindi <math|\<forall\>x<rsub|0>\<in\>\<bbb-R\><rsup|n>:>\ 

    <\equation*>
      <frac|1|2>*x<rsub|0><rsup|T>*P<rsub|T><around*|(|0|)>x<rsub|0>\<leqslant\><frac|1|2>*x<rsub|0><rsup|T><around*|(|<big|int><rsub|0><rsup|T>e<rsup|<around*|(|A+B*K|)><rsup|T>\<tau\>><around*|(|Q+K<rsup|T>*R*K|)>*e<rsup|<around*|(|A+B*K|)>\<tau\>>d\<tau\>|)>x<rsub|0>
    </equation*>

    <\equation*>
      \<leqslant\><frac|1|2>x<rsub|0><rsup|T><around*|(|<big|int><rsub|0><rsup|\<infty\>>e<rsup|<around*|(|A+B*K|)><rsup|T>\<tau\>><around*|(|Q+K<rsup|T>*R*K|)>*e<rsup|<around*|(|A+B*K|)>\<tau\>>d\<tau\>|)>x<rsub|0>=<frac|1|2>x<rsub|0><rsup|T>*<wide|P|^>*x<rsub|0>
    </equation*>

    <\equation*>
      \<Longrightarrow\>P<rsub|T><around*|(|0|)>\<leqslant\><wide|P|^>
    </equation*>
  </answer*>

  <section*|<with|font-series|bold|Enunciare il teorema di esistenza della
  soluzione del LQR ad orizzonte infinito. Dimostrare che il sistema a ciclo
  chiuso con la soluzione di LQR risulta asintoticamente stabile.>>

  <\answer*>
    Il teorema di esistenza della soluzione di un problema LQR ad orizzonte
    infinito fonrisce condizioni sufficienti di essitenza della soluzione. In
    particolare, considerato il problema LQR su orizzonte infinito con
    <math|M=0,R\<succ\>0,Q=D<rsup|T>*D\<succcurlyeq\>0>. Supponiamo che la
    coppia <math|<around*|(|A,D|)>> sia osservabile e
    <math|<around*|(|A,B|)>> controllabile. Allora:

    <\itemize>
      <item>Esiste un'unica soluzione definita positiva <math|<overline|P>>
      dell'equazione algebrica di riccati;

      <item>Il sistema a ciclo chiuso:

      <\equation*>
        <wide|x|\<dot\>>=<around*|(|A-B*R<rsup|-1>B<rsup|T>*<overline|P>|)>x
      </equation*>

      ha un equilibrio in zero asintoticamente stabile.
    </itemize>

    Per dimostrare che il sistema a ciclo chiuso è asintoticamente stabile
    occorre dimostrare perliminarmente la stabilità del sistema a ciclo
    chiuso e poi l'attrattività dei moti tramite il teorema di LaSalle,
    prendiamo come funzione di Lyapunov la funzione valore
    <math|V<around*|(|x|)>=<frac|1|2>x<rsup|T>*P*x> e quest'ultima deve
    risultate:

    <\enumerate>
      <item>La matrice <math|<overline|P>> è definita positva;

      <item><math|<wide|V|\<dot\>>> è definita negativa.
    </enumerate>

    Per il primo punto si suppone per assurdo che <math|<overline|P>> sia
    semidefinita positiva. Quindi essiste una condizione iniziale non nulla
    per cui:

    <\equation*>
      <overline|P>x<rsub|0>=0\<Longrightarrow\>x<rsub|0><rsup|T>*<overline|P>x<rsub|0>=0\<Longrightarrow\><big|int><rsub|0><rsup|\<infty\>><around*|(|x<around*|(|t|)><rsup|T>*D<rsup|T>*D*e<rsup|A
      t>+u<around*|(|t|)><rsup|T>*R<rsup|>*u<around*|(|t|)>|)>d t=0
    </equation*>

    Dato che <math|R\<succ\>0\<Longrightarrow\>u<around*|(|t|)>=0<space|1em>\<forall\>t\<Longrightarrow\><wide|x|\<dot\>>=A*x\<Longrightarrow\>x<around*|(|t|)>=e<rsup|A
    t>x<rsub|0>=0>. Essendo <math|<around*|(|A,D|)>> osservabile, la matrice
    Gramiana di osservabilità è definita positiva e l'unica condizione
    iniziale possibile è <math|x<rsub|0>=0>. Ciò è un'assurdo.

    Per dimostrare il secondo punto,effettuiamo la derivata lungo le
    traiettorie del sistema a ciclo chiuso:

    <\equation*>
      <wide|V|\<dot\>>=x<rsup|T><overline|P><around*|(|A-B*R<rsup|-1>*B<rsup|T><overline|P>|)>x=<frac|1|2>x<rsup|T><around*|(|<overline|P>*A+A<rsup|T><overline|P>-2<overline|P>B*R<rsup|-1>B<rsup|T><overline|P>|)>x=-<frac|1|2>x<rsup|T>*Q*x-<frac|1|2>x<rsup|T><overline|P>B*R<rsup|-1>B<rsup|T><overline|P>x
    </equation*>

    Per ottenere la definita negatività, occorre avere per ogni <math|x>
    almeno uno dei due termini positivi:

    <\itemize>
      <item><math|Q\<succ\>0>, ma per ipotesi <math|Q\<succcurlyeq\>0>;

      <item><math|<wide|P|~>B*R<rsup|-1>*B<rsup|T><wide|P|~>\<succ\>0>,ma
      <math|B*R<rsup|-1>*B<rsup|T>> ha rango pieno solo se m=n
    </itemize>

    Quindi possiamo concludere che <math|<wide|V|\<dot\>>\<preccurlyeq\>0>.Quindi
    la stabilità semplice del sistema. Per affermare la stabilità asintotica
    del sistema dobbiamo utilizzare il teorema di LaSalle sull'attrattività
    dei moti di un sistema autonomo.\ 

    <with|font-series|bold|Teorema di LaSalle>

    Consideriamo un sistema autonomo <math|<wide|x|\<dot\>>=A*x>.

    <\itemize>
      <item>Sia <math|\<Omega\>\<subset\>\<bbb-R\><rsup|n>> un insieme
      compatto positivamente invariante per il sistema

      <item>Sia <math|V:\<bbb-R\><rsup|n>\<longrightarrow\>\<bbb-R\>> una
      funzione <math|C<rsup|1>> tale che <math|<wide|V|\<dot\>>\<leqslant\>0>

      <item>Sia <math|E> insieme dei punti in <math|\<Omega\>> tale che
      <math|<wide|V|\<dot\>>=0>

      <item>Sia <math|M> il più grande insieme invariante contenuto in
      <math|E>
    </itemize>

    Allora ogni soluzione converge a <math|M> per
    <math|t\<rightarrow\>\<infty\>>.

    Quindi,Sappiamo che:\ 

    <\itemize>
      <item><math|V<around*|(|x|)>> è quadratica e i suoi insiemi di livello
      sono ellissoidi compatti;

      <item><math|V<around*|(|x<around*|(|t|)>|)>\<leqslant\>V<around*|(|x<rsub|0>|)>
      \<forall\>t\<geqslant\>0>
    </itemize>

    Dunque, possiamo scegliere un insieme compatto positivamente invariante
    per il sistema:

    <\equation*>
      \<Omega\>=<around*|{|x\<in\>\<bbb-R\><rsup|n>:V<around*|(|x|)>\<leqslant\>V<around*|(|x<rsub|0>|)>|}>
    </equation*>

    Quindi, per caratterizzare l'insieme invariante
    <math|M\<subset\>E=<around*|{|x:<wide|V|\<dot\>>=0|}>>

    <\equation*>
      <wide|V|\<dot\>>=0\<Longrightarrow\>x<around*|(|t|)><rsup|T>*D<rsup|T>*D*x<around*|(|t|)>=0\<Longrightarrow\>D*x<around*|(|t|)>=0<space|1em>\<forall\>t
    </equation*>

    <\equation*>
      M=<around*|{|x\<in\>\<bbb-R\><rsup|n>:D*e<rsup|A t>*x=0,\<forall\>t|}>
    </equation*>

    Grazie all'ipotesi di osservabilità, è possibile distinguere due uscite
    di due qualsiasi condizioni iniziali diverse. Quindi:

    <\itemize>
      <item>La condizione iniziale <math|x<rsub|0>=0> forsnisce
      <math|D*e<rsup|A t>*x<rsub|0>=0<space|1em>\<forall\>t>;

      <item>è l'unico stato per cui vale questa proprietà;
    </itemize>

    Allora <math|M=<around*|{|0|}>>. Quindi abbiamo dimostrato l'attrività di
    tutte le soluzioni che, unita alla stabilià, ci forniscono stabilità
    asintotica.
  </answer*>

  <section*|<with|font-series|bold|Enunciare e dimostrare il Principio di
  Ottimalità>.>

  <\answer*>
    Considerato un problema di Bolza. Se <math|u<rsup|\<ast\>>> è ottima
    sull'intervallo <math|<around*|[|t,T|]>> a partire dallo stato
    <math|x<around*|(|t|)>>, allora <math|u<rsup|\<ast\>><around*|(|\<tau\>|)>,\<tau\><around*|[|t+\<Delta\>t,T|]>>
    è necessariamente ottima per un problema di Bolza ristretto
    all'intervallo <math|<around*|[|t+\<Delta\>t,T|]>> a partire da
    <math|x<rsup|\<ast\>><around*|(|t+\<Delta\>t|)> \<forall\>\<Delta\>t>
    tale che <math|0\<less\>\<Delta\>t\<leqslant\>T-t>.

    Per dimostrare il Principio di Ottimalità, supponiamo per assurdo che
    esista <math|u<rsup|\<ast\>\<ast\>>> che fornisce un valore minore
    dell'indice di costo del problema di Bolza ristretto:

    <\equation*>
      <overline|J><around*|(|u|)>=<big|int><rsub|t+\<Delta\>t><rsup|T>l<around*|(|x<around*|(|\<tau\>|)>,u<around*|(|\<tau\>|)>,\<tau\>|)>d\<tau\>+m<around*|(|x<around*|(|T|)>|)>
    </equation*>

    rispetto ad <math|u<rsup|\<ast\>>> in
    <math|<around*|[|t+\<Delta\>T,T|]>>. Quindi
    <math|<overline|J><around*|(|u<rsup|\<ast\>\<ast\>>|)>\<less\><overline|J><around*|(|u<rsup|\<ast\>>|)>>.
    Se ciò è vero, possiamo definire il nuovo controllo <math|<wide|u|^>>:

    <\equation*>
      <wide|u|^><around*|(|\<tau\>|)>=<choice|<tformat|<table|<row|<cell|u<rsup|\<ast\>><around*|(|\<tau\>|)><space|1em>se
      t\<leqslant\>\<tau\>\<leqslant\>t+\<Delta\>t>>|<row|<cell|u<rsup|\<ast\>\<ast\>><around*|(|\<tau\>|)><space|1em>se
      t+\<Delta\>t\<leqslant\>\<tau\>\<leqslant\>T>>>>>
    </equation*>

    Allora, sull'intero intervallo <math|<around*|[|t,T|]>> abbiamo:

    <\equation*>
      <tformat|<table|<row|<cell|J<around*|(|<wide|u|^>|)>>|<cell|=>|<cell|<big|int><rsub|t><rsup|T>l<around*|(|<wide|x|^><around*|(|s|)>,<wide|u|^><around*|(|s|)>,s|)>d
      s+m<around*|(|<wide|x|^><around*|(|T|)>|)>>>|<row|<cell|>|<cell|=>|<cell|<big|int><rsub|t><rsup|t+\<Delta\>t>l<around*|(|x<rsup|\<ast\>><around*|(|s|)>,u<rsup|\<ast\>><around*|(|s|)>,s|)>d
      s+<big|int><rsub|t+\<Delta\>t><rsup|T>l<around*|(|x<rsup|\<ast\>\<ast\>><around*|(|s|)>,u<rsup|\<ast\>\<ast\>><around*|(|s|)>,s|)>d
      s+m<around*|(|x<rsup|\<ast\>\<ast\>><around*|(|T|)>|)>>>|<row|<cell|>|<cell|\<less\>>|<cell|<big|int><rsub|t><rsup|t+\<Delta\>t>l<around*|(|x<rsup|\<ast\>><around*|(|s|)>,u<rsup|\<ast\>><around*|(|s|)>,s|)>d
      s+<big|int><rsub|t+\<Delta\>t><rsup|T>l<around*|(|x<rsup|\<ast\>><around*|(|s|)>,u<rsup|\<ast\>><around*|(|s|)>,s|)>d
      s+m<around*|(|x<rsup|\<ast\>><around*|(|T|)>|)>=J<around*|(|u<rsup|\<ast\>>|)>>>>>
    </equation*>

    Di conseguenza abbiamo contraddetto l'ipotesi per cui
    <math|u<rsup|\<ast\>>> sia la soluzione ottima su
    <math|<around*|[|t,T|]>>.
  </answer*>

  <section*|<with|font-series|bold|Discutere il problema del Tracking e della
  reiezione di disturbi noti.>>

  <\answer*>
    Il problema di Tracking è un problema di minimizzazione del tipo:

    <\equation*>
      min<rsub|u> J<around*|(|u|)>=<frac|1|2><big|int><rsub|0><rsup|T><around*|(|<around*|(|\<xi\><around*|(|t|)>-<wide|\<xi\>|\<dot\>><around*|(|t|)>|)><rsup|T>Q<around*|(|\<xi\><around*|(|t|)>-<wide|\<xi\>|\<dot\>><around*|(|t|)>|)>+u<around*|(|t|)><rsup|T>*R*u<around*|(|t|)>|)>d
      t
    </equation*>

    <\equation*>
      <wide|\<xi\>|\<dot\>><around*|(|t|)>=A\<xi\><around*|(|t|)>+B*u<around*|(|t|)>,\<xi\><around*|(|0|)>=\<xi\><rsub|0>
    </equation*>

    In cui si vuole ottenere lo stato del sistema più vicino possibile ad un
    segnale nel tempo in un intervallo di tempo fissato. Alcune tipologie di
    questo problema possono essere ricondotte ad un LQR con l'ipotesi che,
    fissando il segnale desiderato <math|<wide|\<xi\>|~>>:

    <\equation*>
      A*<wide|\<xi\>|~>-<wide|<wide|\<xi\>|~>|\<dot\>>=0\<longrightarrow\><wide|\<xi\>|~>=<big|sum><rsub|i=1><rsup|\<nu\>><big|sum><rsub|j=0><rsup|\<mu\><rsub|i>>c<rsub|i
      j>*e<rsup|\<lambda\><rsub|i>*t>*t<rsup|j>
    </equation*>

    con condizioni iniziale <math|c<rsub|i j>>, <math|\<nu\>> autovalori di
    <math|A>,<math|\<mu\><rsub|i><rsub|>> molteplicità algebrica di
    <math|\<lambda\><rsub|i>>,<math|\<lambda\><rsub|i>> autovalore i-esmo di
    <math|A>.L'indice di costo è descritto da:

    <\equation*>
      J<around*|(|u|)>=<frac|1|2><big|int><rsub|0><rsup|T><around*|(|x<around*|(|t|)><rsup|T>*Q*x<around*|(|t|)>+u<rsup|T><around*|(|t|)>*R*u<around*|(|t|)>|)>d\<tau\>
    </equation*>

    e il sistema dinamico:

    <\equation*>
      <tformat|<table|<row|<cell|<wide|x|\<dot\>>>|<cell|=>|<cell|<wide|\<xi\>|\<dot\>>-<wide|<wide|\<xi\>|~>|\<dot\>>=A*\<xi\>+B*u-<wide|<wide|\<xi\>|~>|\<dot\>>>>|<row|<cell|>|<cell|=>|<cell|A*<around*|(|x+<wide|\<xi\>|~>|)>+B*u-<wide|<wide|\<xi\>|~>|\<dot\>>=A*x+B*u+<around*|(|A<wide|\<xi\>|~>-<wide|<wide|\<xi\>|~>|\<dot\>>|)>>>|<row|<cell|>|<cell|=>|<cell|A*x+B*u>>>>
    </equation*>
  </answer*>

  Per il principio del modello interno, si può avere tracking perfetto se il
  processo contiente una copia dei modi del segnale di riferimento. Nel caso
  in cui questo principio non venga rispettato si può considerare la
  dinamica:

  <\equation*>
    <wide|x|\<dot\>>=A*x+B*u+w<around*|(|t|)><space|1em>w<around*|(|t|)>\<assign\>disturbo
  </equation*>

  Così facendo, si ottiene u sistema affine e la minimizzazione dell'ìndice
  di costo:

  <\equation*>
    J<around*|(|u|)>=<frac|1|2><big|int><rsub|0><rsup|T><around*|(|x<around*|(|t|)><rsup|T>*Q*x<around*|(|t|)>+u<rsup|T><around*|(|t|)>*R*u<around*|(|t|)>|)>d\<tau\>
  </equation*>

  viene detto problema di reiezione dei disturbi noti in cui vale:

  <\itemize>
    <item>HJB:

    <\equation*>
      <\equation*>
        -<frac|\<partial\>V|\<partial\>t>=min<rsub|u><around*|{|<frac|\<partial\>V|\<partial\>x><around*|(|A*x+B*u+w<around*|(|t|)>|)>+<frac|1|2>x<rsup|T>*Q*x+<frac|1|2>u<rsup|T><around*|(|t|)>*R*u<around*|(|t|)>|}>,V<around*|(|x,T|)>=0<space|1em>\<forall\>x\<in\>\<bbb-R\><rsup|n>,t\<in\><around*|[|0,T|]>
      </equation*>
    </equation*>

    <item>La funzione valore:

    <\equation*>
      V<around*|(|x,t|)>=<frac|1|2>x<rsup|T>*P<around*|(|t|)>*x+b<around*|(|t<rsup|>|)><rsup|T>*x+c<around*|(|t|)>,P<around*|(|t|)>\<in\>\<bbb-R\><rsup|n\<times\>n>,b<around*|(|t|)>\<in\>\<bbb-R\><rsup|n\<times\>1>,c<around*|(|t|)>\<in\>\<bbb-R\>
    </equation*>

    e il controllo ottimo:

    <\equation*>
      u<rsup|\<ast\>>=-R<rsup|-1>*B<rsup|T><around*|(|P<around*|(|t|)>*x+b<around*|(|t|)>|)>=-R<rsup|-1>B<rsup|T>*P<around*|(|t|)>*x-R<rsup|-1>*B<rsup|T>b<around*|(|t|)>
    </equation*>

    Infine la soluzione di HJB, si ottiene sostituendo il controllo ottimo
    nell'equazione HJB.
  </itemize>

  <section*|Dimostrare che l'equazione di Hamilton Jacobi Bellman fornisce
  condizioni sufficienti di ottimalità.>

  <\answer*>
    Vogliamo dimostrare che se la funzione <math|<wide|V|^>> risolve HJB,
    allora questa funzione è la funzione valore. A tale scopo, se
    <math|<wide|V|^>> risolve HJB e <math|<wide|u|^>> raggiunge il minmo del
    termine di destra di HJB:

    <\equation*>
      <wide|u|^><around*|(|t|)>=arg min<rsub|u><around*|{|l<around*|(|x,u,t|)>+<frac|\<partial\><wide|V|^>|\<partial\>x><around*|(|x,t|)>*f<around*|(|x,u,t|)>|}><space|1em>\<forall\>x,\<forall\>t
    </equation*>

    Allora lungo la traiettoria <math|<wide|x|^><around*|(|t|)>> a partire
    dalla condizione iniziale <math|<wide|x|^><around*|(|t<rsub|0>=x<rsub|0>|)>,si
    ha:>

    <\equation*>
      -<frac|\<partial\><wide|V|^>|\<partial\>t><around*|(|<wide|x|^><around*|(|t|)>,t|)>=l<around*|(|<wide|x|^><around*|(|t|)>,<wide|u|^><around*|(|t|)>,t|)>+<frac|\<partial\><wide|V|^>|\<partial\>x>*<around*|(|<wide|x|^><around*|(|t|)>,t|)>f<around*|(|<wide|x|^><around*|(|t|)>,<wide|u|^><around*|(|t|)>,t|)>
    </equation*>

    Ricordando che;

    <\equation*>
      <frac|d|d t><wide|V|^><around*|(|<wide|x|^><around*|(|t|)>,t|)>=<frac|\<partial\>|\<partial\>x><wide|V|^><around*|(|<wide|x|^><around*|(|t|)>,t|)>*f<around*|(|<wide|x|^><around*|(|t|)>,<wide|u|^><around*|(|t|)>,t|)>+<frac|\<partial\>|\<partial\>t>*<wide|V|^><around*|(|<wide|x|^><around*|(|t|)>,t|)>
    </equation*>

    Si ottiene:

    <\equation*>
      0=l<around*|(|<wide|x|^><around*|(|t|)>,<wide|u|^><around*|(|t|)>,t|)>+<frac|d|d
      t><wide|V|^><around*|(|<wide|x|^><around*|(|t|)>,t|)>
    </equation*>

    Integrando:

    <\equation*>
      0=<big|int><rsub|t<rsub|0>><rsup|T>l<around*|(|<wide|x|^><around*|(|t|)>,<wide|u|^><around*|(|t|)>,t|)>d
      t+<big|int><rsub|t<rsub|0>><rsup|T><frac|d|d t
      ><wide|V|^><around*|(|<wide|x|^><around*|(|t|)>,t|)>d t
    </equation*>

    <\equation*>
      0=J<around*|(|<wide|u|^>|)>-<wide|V|^><around*|(|<wide|x|^><around*|(|t<rsub|0>|)>,t<rsub|0>|)>\<rightarrow\>J<around*|(|<wide|u|^>|)>=<wide|V|^><around*|(|<wide|x|^><around*|(|t<rsub|0>|)>,t<rsub|0>|)>
    </equation*>

    Ora dobbiamo dimostrare che questo costo è minimo e quindi confrontarlo
    con quello ottenuto da una qualsiasi altra u:

    <\equation*>
      -<frac|\<partial\><wide|V|^>|\<partial\>t><around*|(|x<around*|(|t|)>,t|)>\<leqslant\>l<around*|(|x<around*|(|t|)>,u<around*|(|t|)>,t|)>+<frac|\<partial\><wide|V|^>|\<partial\>x><around*|(|x<around*|(|t|)>,u<around*|(|t|)>,t|)>
    </equation*>

    <\equation*>
      0\<leqslant\>l<around*|(|x<around*|(|t|)>,u<around*|(|t|)>,t|)>+<frac|d|d
      t><wide|V|^><around*|(|x<around*|(|t|)>,t|)>
    </equation*>

    Integrando:

    <\equation*>
      <tformat|<table|<row|<cell|0>|<cell|\<leqslant\>>|<cell|<big|int><rsub|t<rsub|0>><rsup|T>l<around*|(|x<around*|(|t|)>,u<around*|(|t|)>,t|)>d
      t+<big|int><rsub|t<rsub|0>><rsup|T><frac|d|d
      t><wide|V|^><around*|(|x<around*|(|t|)>,t|)>d
      t=<big|int><rsub|t<rsub|0>><rsup|T>l<around*|(|x<around*|(|t|)>,u<around*|(|t|)>,t|)>d
      t+m<around*|(|x<around*|(|T|)>|)>-<wide|V|^><around*|(|x<rsub|0>,t<rsub|0>|)>>>>>
    </equation*>

    Quindi:

    <\equation*>
      <wide|V|^><around*|(|x<rsub|0>,t<rsub|0>|)>\<leqslant\>J<around*|(|u|)>
    </equation*>

    <\equation*>
      J<around*|(|<wide|u|^>|)>\<leqslant\>J<around*|(|u|)><space|1em>\<forall\>u
    </equation*>
  </answer*>

  <section*|Dare definizione di Value Iteration>

  <\answer*>
    Il value iteration è un algoritmo iterativo per determinare la funzione
    valore ottima, per ciascun valore dello stato, in un problema di
    Reinforcement Learning. Si ottiene considerando un algoritmo di Policy
    Improvement ed eseguendo la fase di policy evaluation troncata ad un
    singolo passo.

    Il risultato complessivo di questa strategia è quella di trasformare la
    legge di Bellman in una legge di aggiornamento:

    <\equation*>
      v<rsub|i+1><around*|(|x|)>=max<rsub|k><around*|{|R<rsub|k+1>+\<gamma\>*v<rsub|i><around*|(|x<rprime|'>|)>|}><rsub|>
    </equation*>
  </answer*>

  <section*|Dare definizione di Policy Improvement>

  <\answer*>
    Il policy improvement è un algoritmo iterativo che, per un certo istante
    di tempo e per un certo stato,ci dice che c'è un'azione tra quelle
    disponibili che fornisce una ricompensa maggiore per poi seguire la
    policy di partenza. Ripetendo questa operazione per ogni stato si
    ridefinisce l'intera policy per ottenerne una migliore aggiornando la
    policy <math|\<pi\>> in maniera greedy rispetto alla funzione qualità
    <math|q<rsub|\<pi\>><around*|(|x,u|)>>. In particolare la funzione valore
    delle policy risultante:

    <\equation*>
      v<rsub|\<pi\><rprime|'>><around*|(|x|)>\<geqslant\>v<rsub|\<pi\>><around*|(|x|)>
    </equation*>
  </answer*>

  <section*|Dare definizione di Policy Evaluation>

  <\answer*>
    L'algoritmo di Policy Evaluation è un algoritmo iterativo che permette di
    determinare il valore <math|v<rsub|\<pi\>><around*|(|x|)>> della policy
    <math|\<pi\>.> In particolare, ogni passo di iterazione poniamo:

    <\equation*>
      v<rsub|i+1><around*|(|x|)>=R<rsub|k+1>+\<gamma\>*v<rsub|i><around*|(|x<rprime|'>|)>
    </equation*>

    e all'infinito, dopo aver aggiornato tutti gli stati senza cambiarne il
    valore, si converge ad un punto fisso definito come:

    <\equation*>
      v<rsub|\<pi\>><around*|(|x|)>=R<rsub|k+1>+\<gamma\>*v<rsub|\<pi\>><around*|(|x<rprime|'>|)>
    </equation*>
  </answer*>

  <section*|Dare definizione di Funzione Valore in un contesto di
  Reinforcement Learning>

  <\answer*>
    La funzione valore è una funzione che fornisce il valore di uno stato,
    ovvero quanto ricavo si potrebbe ottenere in futuro per il fatto di
    trovarsi in quel particolare stato in funzione delle azioni eseguite:

    <\equation*>
      v<rsub|\<pi\>><around*|(|x|)>=G<rsub|k><around*|(|x|)>=<big|sum><rsub|i=0><rsup|\<infty\>>\<gamma\><rsup|i><rsup|>*R<rsub|k+i+1>=R<rsub|k+1>+\<gamma\>*v<rsub|\<pi\>><around*|(|x<rsub|k+1>|)>
    </equation*>

    In cui i <math|R<rsub|k+i+1>> sono ottenuti ad ogni passo seguendo la
    policy <math|\<pi\>>. Nel caso stocastico equivale a:

    <\equation*>
      v<rsub|\<pi\>><around*|(|x|)>=\<bbb-E\><around*|[|G<rsub|t>\|S<rsub|t>|]>=<big|sum><rsub|u>\<pi\><around*|(|u\|x|)><big|sum><rsub|x<rprime|'>><big|sum><rsub|r>p<around*|(|x<rprime|'>,r\|x,u|)>*<around*|(|r+\<gamma\>*v<rsub|\<pi\>><around*|(|x<rprime|'>|)>|)>=<big|sum><rsub|u>\<pi\><around*|(|u\|x|)>q<rsub|\<pi\>><around*|(|x,u|)>
    </equation*>

    In particolare:

    <\itemize>
      <item><math|\<pi\><around*|(|u\|x|)>\<assign\>>prob. di prendere
      l'azione u dallo stato x;

      <item><math|p<around*|(|x<rprime|'>,r\|x,u|)>\<assign\>>prob. di finire
      in <math|x<rprime|'>> ottenendo il reward <math|r> partendo dallo stato
      <math|x> e scegliendo l'azione <math|u>;

      <item><math|<around*|(|r+\<gamma\>*v<rsub|\<pi\>><around*|(|x<rprime|'>|)>|)>\<assign\>>funzione
      valore dello stato x;

      <item><math|q<rsub|\<pi\>><around*|(|x,u|)>\<assign\>>funzione qualità.
    </itemize>
  </answer*>

  <section*|Dare definizione di Funzione Qualità>

  <\answer*>
    La funzione qualità è una funzione valore stato-azione in cui all'istante
    <math|k> si esegue l'azione <math|u> e dall'istante <math|k+1> si esegue
    la policy <math|\<pi\>>. Nel caso deterministico è definita come:

    <\equation*>
      q<rsub|\<pi\>><around*|(|x,u|)>=R<rsub|k+1>+<big|sum><rsub|i=1><rsup|\<infty\>>\<gamma\><rsup|i>*R<rsub|k+i+1>
    </equation*>

    Invece, nel caso stocastico:

    <\equation*>
      q<rsub|\<pi\>><around*|(|x,u|)>=<big|sum><rsub|x<rprime|'>><big|sum><rsub|r>p<around*|(|x<rprime|'>,r\|x,u|)>*<around*|(|r+\<gamma\>*v<rsub|\<pi\>><around*|(|x<rprime|'>|)>|)>
    </equation*>

    Viene utilizzata nel policy Improvement per migliorare la policy
    <math|\<pi\>>
  </answer*>

  <section*|Discutere di MPC e dimostrare la ammissibilità,stabilità.>

  <\answer*>
    Nel model predictive control l'obiettivo è quello di minimizzare un
    indice di costo<space|2em><math|J<around*|(|u|)>=<big|sum><rsub|t=0><rsup|\<infty\>><around*|(|x<rsup|T>*Q*x+u<rsub|t><rsup|T>R
    u<rsub|t>|)>> \ in cui, ad ogni istante di tempo, si misura il valore
    dello stato corrente <math|x<around*|(|t|)>>, si risolve un problema di
    ottimizzazione dinamica a batch in una finestra di <math|N<rsub|u>> passi
    di cui si implementa solo la prima azione ottima
    <math|u<rsub|0><rsup|\<ast\>>>. Questo problema è di ottimizzazione
    statica a cui si possono aggiungere eventualmente dei vincoli.

    Per dimostrare l'ammissibilità e la stabilità, consideriamo il sistema
    lineare <math|x<rsub|t+1>=A*x<rsub|t>+B*u<rsub|t>,t=0,1,\<ldots\>n><space|1em>e
    supponiamo che la strategia di MPC sia basata sul seguente problema QP:

    <\equation*>
      V<rsup|\<ast\>><around*|(|x<around*|(|t|)>|)>=min<rsub|u><big|sum><rsub|k=0><rsup|N<rsub|u>-1>x<rsub|k><rsup|T>Q*x<rsub|k>+u<rsub|k><rsup|T>*R*u<rsub|k>
    </equation*>

    <\equation*>
      s.t.
    </equation*>

    <\equation*>
      x<rsub|k+1>=A*x<rsub|k>+B*u<rsub|k>,x<rsub|0>=x<around*|(|t|)>
    </equation*>

    <\equation*>
      u<rsub|min>\<leqslant\>u<rsub|k>\<leqslant\>u<rsub|max>
    </equation*>

    <\equation*>
      y<rsub|min>\<leqslant\>C*x<rsub|k>\<leqslant\>y<rsub|max>
    </equation*>

    <\equation*>
      x<rsub|N<rsub|u>>=0\<longrightarrow\><with|font-series|bold|vincolo
      terminale>
    </equation*>

    con <math|Q\<gtr\>0,R\<gtr\>0,u<rsub|min>\<less\>0\<less\>u<rsub|max>,y<rsub|min>\<less\>0\<less\>y<rsub|max>.>Allora,
    <with|font-series|bold|se il problema QP è ammissibile al tempo> t=0:

    <\equation*>
      lim<rsub|t\<rightarrow\>\<infty\>>x<rsub|t>=0<space|2em>lim<rsub|t\<rightarrow\>\<infty\>>u<rsub|t>=0
    </equation*>

    ed i vincoli sono soddisfatti per ogni t.

    <\proof>
      \;

      Supponiamo che <math|U<rsub|t><rsup|\<ast\>>=<around*|[|u<rsub|0><rsup|t>,\<ldots\>,u<rsub|N-1><rsup|t>|]>>
      sia la soluzione ottima di QP al tempo t con valore
      <math|V<rsup|\<ast\>><around*|(|x<around*|(|t|)>|)>>. Dal momento che
      <math|U<rsub|t><rsup|\<ast\>>> è ammissibile, sappiamo che
      <math|x<rsub|t+N<rsub|U>>=0>;

      Di conseguenza, la sequenza <math|U<rsub|t+1>=><math|<around*|[|u<rsub|1><rsup|t>,\<ldots\>,u<rsub|N-1><rsup|t>,0|]>>
      è ammissibile per QP al tempo t+1. Infatti:

      <\itemize>
        <item><math|x<around*|(|t+1|)>=x<around*|(|t+1\|t|)>> dato che
        abbiamo utilizzato <math|u<rsub|0><rsup|t>>;

        <item>La sequenza <math|U<rsub|t+1>> è tale che
        <math|x<around*|(|t+N<rsub|u>\|t+1|)>=x<around*|(|t+N<rsub|u>+1\|t+1|)>=0>
      </itemize>

      Ora, il costo <math|U<rsub|t+1>> è:

      <\equation*>
        V<rsup|\<ast\>><around*|(|x<around*|(|t|)>|)>-x<around*|(|t|)><rsup|T>Q*x<around*|(|t|)>-u<around*|(|t|)><rsup|T>R*u<around*|(|t|)>\<geqslant\>V<rsup|\<ast\>><around*|(|x<around*|(|t+1|)>|)>
      </equation*>

      è maggiore del valore ottimo a <math|t+1>:

      <\equation*>
        \<Longrightarrow\>V<rsup|\<ast\>><around*|(|x<around*|(|t|)>|)> è
        monoticamente descrente e lmitata inferiormente
      </equation*>

      <\equation*>
        \<exists\>lim<rsub|t\<rightarrow\>\<infty\>>V<rsup|\<ast\>><around*|(|x<around*|(|t|)>|)>\<backassign\>V<rsub|\<infty\>>
      </equation*>

      Dunque <math|0\<leqslant\>><math|x<around*|(|t|)><rsup|T>Q*x<around*|(|t|)>+u<around*|(|t|)><rsup|T>R*u<around*|(|t|)>\<leqslant\>><math|V<rsup|\<ast\>><around*|(|x<around*|(|t|)>|)>-><math|V<rsup|\<ast\>><around*|(|x<around*|(|t+1|)>|)>\<rightarrow\>0><space|1em>per
      <math|t\<longrightarrow\>\<infty\>> e la tesi segue dal fatto che Q ed
      R sono matrici definite positive.

      \;
    </proof>
  </answer*>

  \;

  <section*|<with|font-series|bold|Enunciare il teorema di essitenza della
  soluzione del LQR ad orizzonte infinito. L'unicità della soluzione
  stabilizzante di ARE.>>

  <\answer*>
    Il teorema di esistenza della soluzione di un problema LQR ad orizzonte
    infinito fonrisce condizioni sufficienti di essitenza della soluzione. In
    particolare, considerato il problema LQR su orizzonte infinito con
    <math|M=0,R\<succ\>0,Q=D<rsup|T>*D\<succcurlyeq\>0>. Supponiamo che la
    coppia <math|<around*|(|A,D|)>> sia osservabile e
    <math|<around*|(|A,B|)>> controllabile. Allora:

    <\itemize>
      <item>Esiste un'unica soluzione definita positiva <math|<overline|P>>
      dell'equazione algebrica di riccati;

      <item>Il sistema a ciclo chiuso:

      <\equation*>
        <wide|x|\<dot\>>=<around*|(|A-B*R<rsup|-1>B<rsup|T>*<overline|P>|)>x
      </equation*>

      ha un equilibrio in zero asintoticamente stabile.
    </itemize>

    Per dimostrare l'unicità della soluzione stabilizzante di ARE, supponiamo
    che esistano due matrici <math|<wide|P|~><rsub|1>> e
    <math|<wide|P|~><rsub|2>> che soddisfano:

    <\eqnarray*>
      <tformat|<table|<row|<cell|0>|<cell|=>|<cell|<wide|P|~><rsub|1*>*A+A<rsup|T>*<wide|P|~><rsub|1>+Q-<wide|P|~><rsub|1>*B*R<rsup|-1>*B<rsup|T>*<wide|P|~><rsub|1><space|1em>A<rsub|cl,1>=A-B*R<rsup|-1>*B<rsup|T><wide|P|~><rsub|1><space|1em>\<sigma\><around*|(|A<rsub|cl,1>|)>\<subset\>\<bbb-C\><rsup|->>>|<row|<cell|0>|<cell|=>|<cell|<wide|P|~><rsub|2*>*A+A<rsup|T>*<wide|P|~><rsub|2>+Q-<wide|P|~><rsub|2>*B*R<rsup|-1>*B<rsup|T>*<wide|P|~><rsub|2><space|1em>A<rsub|cl,2>=A-B*R<rsup|-1>*B<rsup|T><wide|P|~><rsub|2><space|1em>\<sigma\><around*|(|A<rsub|cl,2>|)>\<subset\>\<bbb-C\><rsup|->>>>>
    </eqnarray*>

    Sottraiedno la seconda equazione dalla prima e sommando e sottraendo
    <math|<wide|P|~><rsub|2>B*R<rsup|-1>*B<rsup|T><wide|P|~><rsub|2>>
    otteniamo:

    <\equation*>
      0=<around*|(|<wide|P|~><rsub|1>-<wide|P|~><rsub|2>|)>*A<rsub|cl,1>+A<rsub|cl,2><rsup|T><around*|(|<wide|P|~><rsub|1>-<wide|P|~><rsub|2>|)><space|1em><with|font-series|bold|Equazione
      di Sylvester>
    </equation*>

    <underline|<with|font-series|bold|Equazione di Sylvester>>

    Un'equazione di Sylvester è un'equazione matriciale lineare
    nell'incognita <math|X> della forma\ 

    <\equation*>
      X*A+B*X=0
    </equation*>

    <math|A,B,C> matrici note di coefficienti. Quale che sia C, l'equazione
    ammette un'unica soluzione se e solo se
    <math|\<sigma\><around*|(|A|)>\<cap\>\<sigma\><around*|(|-B|)>=\<varnothing\>,\<sigma\><around*|(|-A<rsub|cl,2><rsup|T>|)>\<subseteq\>\<bbb-C\><rsup|+>>

    L'unica soluzione è dunque :

    <\equation*>
      <around*|(|<wide|P|~><rsub|1>-<wide|P|~><rsub|2>|)>=0\<longrightarrow\><wide|P|~><rsub|1>=<wide|P|~><rsub|2>
    </equation*>
  </answer*>

  <section*|Principio Ottimalità (Programmazione Quadratica)>

  <\answer*>
    Una politica decisionale ottima ha la proprietà che, qualche che sia la
    configurazione iniziale e le decisioni iniziali, se consideriamo un punto
    intermedio, le decisioni rimanenti della polica devono costituire una
    soluzione ottima rispetto alla configurazione raggiunta dalla prima parte
    delle decisione.
  </answer*>

  <section*|Equazione di Bellman e Soluzione ricorsia di Bellman>

  <\answer*>
    <\equation*>
      <choice|<tformat|<table|<row|<cell|v<rsub|k><around*|(|x<rsub|k>|)>=min<rsub|u<rsub|k>\<in\>U<rsub|k>><around*|{|g<rsub|k><around*|(|x<rsub|k>,u<rsub|k>|)>+V<rsub|k+1><around*|(|f<around*|(|x<rsub|k>,u<rsub|k>|)>|)>|}><space|1em>\<forall\>x<rsub|k>\<in\>X<space|1em>k=<around*|{|0,1,\<ldots\>,N|}>>>|<row|<cell|V<rsub|N><around*|(|x<rsub|N>|)>=g<rsub|N><around*|(|x<rsub|N>|)><space|1em>\<forall\>x<rsub|N>\<in\>X>>>>>
    </equation*>

    Questa equazione si risolve ricorsivamente all'indietor, cioè si parte
    dal punto finale e tornando indietro, si ricostruiscono gli ingressi
    ottimali. In altre parole:

    Dopo aver calcolato il valore di lungo periodo,
    l'<with|font-series|bold|azione ottima> è quella che trasferisce il
    sistema nello stato a maggior valore:

    <\equation*>
      u<rsub|k><rsup|\<ast\>><around*|(|x<rsub|k>|)>=arg
      min<rsub|u<rsub|k>\<in\>U<rsub|k>><around*|{|g<rsub|k><around*|(|x<rsub|k>,u<rsub|k>|)>+V<rsub|k+1><around*|(|x<rsub|k+1>|)>|}>
    </equation*>

    Come abbiamo già detto l'equazione di Bellman si può risolvere
    ricorsivamente all'indietro, quindi <with|font-series|medium|consideriamo
    l'istante terminale N>, il costo migliore a partire da <math|x<rsup|1>>
    al tempo <math|N> è pari al costo terminale <math|g<rsub|N>> valutato in
    <math|x<rsup|1>.> Possiamo ora assegnare il costo ottimo al tempo
    <math|N> a ciascuno stato in <math|X>, calcolando
    <math|V<rsub|N><around*|(|\<cdot\>|)>>.<with|font-series|medium|Facendo
    un passo indietro a N-1>, il costo della scelta 1 è
    <math|c<rsub|1>+V<rsub|N><around*|(|x<rsup|1>|)>>.

    Conosciamo tutti i costi <math|V<rsub|N><around*|(|x<rsup|i>|)>>, quindi
    possiamo determinare la migliore scelta da <math|x<rsup|1>> al tempo N-1:

    <\equation*>
      V<rsub|N-1><around*|(|x<rsup|1>|)>=min<rsub|i><around*|{|c<rsub|i>+V<rsub|N><around*|(|x<rsup|i>|)>|}>
    </equation*>

    Ora, ragionando al generico istante k, per il principio di ottimalità, la
    coda della soluzione ottima da k deve necessariamente coincidere con
    <math|V<rsub|k+1><around*|(|x<rsup|1>|)>>.
    <with|font-series|medium|Scelte greedy basate su considerazioni
    istantanee rispetto ad una funzione che racchiude anche le conseguenze
    future.>
  </answer*>

  <section*|Processo Decisionale di Markov Stocastico>

  <\answer*>
    Un processo Markoviano stocastico è un processo Markoviano in cui il
    comportamento dell'ambiente ( che possiede la proprietà markoviana di
    stato), il coomportamento dell'agente e la ricompensa è definita come
    segue:

    <\itemize>
      <item>lo stato successivo sia <math|x<rprime|'>> e la ricompensa
      <math|r>, specificando la <with|font-series|bold|funzione di massi di
      probabilità:>

      <\equation*>
        p<around*|(|x<rprime|'>,r\|x,u|)>=Pr<around*|[|R<rsub|k+1>=r,X<rsub|k+1>=x<rprime|'>\|X<rsub|k>,U<rsub|k>|]>
      </equation*>

      In cui <math|R,X,U> rappresentano le variabili aleatorie discrete da
      cui possiamo calcolare la <with|font-series|bold|probabilità di
      transizione di stato>:

      <\equation*>
        p<around*|(|x<rprime|'>,\|x,u|)>=<big|sum><rsub|r>p<around*|(|x<rprime|'>,r\|x,u|)>
      </equation*>

      <item>si descriva una <with|font-series|bold|policy> come una
      distribuzione di probabilità <math|\<pi\><around*|(|u\|x|)>>

      <item>l'<with|font-series|bold|obbiettivo> sia di massimizzazione del
      valore atteso del ricavo:

      <\equation*>
        E<rsub|\<pi\>><around*|[|G<rsub|k>\|X<rsub|k>=x|]>=E<rsub|\<pi\>><around*|[|<big|sum><rsub|i=0><rsup|\<infty\>>R<rsub|k+i+1>\|X<rsub|k>=x|]>
      </equation*>

      \;
    </itemize>

    Ottenendo la corrispettiva funzione valore <math|v<rsub|\<pi\>>:>

    <\equation*>
      v<rsub|\<pi\>>=<big|sum><rsub|u>\<pi\><around*|(|u\|x|)>*<big|sum><rsub|x<rprime|'>><big|sum><rsub|r>p<around*|(|x<rprime|'>,r\|x,u|)><around*|[|r+\<gamma\>*v<rsub|\<pi\>><around*|(|x<rprime|'>|)>|]>
    </equation*>

    e la funzione valore stato:

    <\equation*>
      q<rsub|\<pi\>><around*|(|x,u|)>=<big|sum><rsub|x<rprime|'>><big|sum><rsub|r>p<around*|(|x<rprime|'>,r\|x,u|)>*<around*|[|r+\<gamma\>*v<rsub|\<pi\>><around*|(|x<rprime|'>|)>|]>
    </equation*>

    Nel caso ottimo <math|v<rsub|\<ast\>>:>

    <\equation*>
      v<rsub|\<ast\>>=max<rsub|u><big|sum><rsub|x<rprime|'>><big|sum><rsub|r>p<around*|(|x<rprime|'>,r\|x,u|)><around*|[|r+\<gamma\>*v<rsub|\<pi\>><around*|(|x<rprime|'>|)>|]>
    </equation*>
  </answer*>

  <section*|Discutere l'equazione differenziale di Riccati e dimostrare
  esistenza soluzione tramite matrice Hamiltoniana>

  <\answer*>
    Supponiamo che <math|H> non abbia autovalori puramente immaginari, dunque
    <math|n> a parte reale positiva (instabili) e <math|n> a parte reale
    negativa (stabili).

    Esiste semptre una trasformazione non-singolare <math|U> tale che:

    <\equation*>
      U<rsup|-1>*H*U=<matrix|<tformat|<table|<row|<cell|\<Lambda\><rsub|s>>|<cell|0>>|<row|<cell|0>|<cell|\<Lambda\><rsub|u>>>>>>
    </equation*>

    in cui <math|\<Lambda\><rsub|s>/\<Lambda\><rsub|u>> raccolgono tutti i
    blocchi di Jordan associati ad autovalori
    <with|font-series|bold|stabili/instabili>.

    Partizioniamo, di conseguenza, anche <math|U> in maniera coerente come:

    <\equation*>
      U=<matrix|<tformat|<table|<row|<cell|U<rsub|11>>|<cell|U<rsub|12>>>|<row|<cell|U<rsub|21>>|<cell|U<rsub|22>>>>>>
    </equation*>

    dove:

    <\equation*>
      <matrix|<tformat|<table|<row|<cell|U<rsub|11>>>|<row|<cell|U<rsub|21>>>>>>/<matrix|<tformat|<table|<row|<cell|U<rsub|12>>>|<row|<cell|U<rsub|22>>>>>>
    </equation*>

    hanno come colonne gli autovettori generalizzati di <math|H>
    corrispondenti agli autovalori <with|font-series|bold|stabili/instabili.>

    Ora, consideriamo il <with|font-series|bold|cambio di coordiante> per il
    sistema Hamiltoniano:

    <\equation*>
      <matrix|<tformat|<table|<row|<cell|X>>|<row|<cell|Y>>>>>=U*<matrix|<tformat|<table|<row|<cell|<wide|X|^>>>|<row|<cell|<wide|Y|^>>>>>>\<Rightarrow\><matrix|<tformat|<table|<row|<cell|<wide|X|^>>>|<row|<cell|<wide|Y|^>>>>>>=U<rsup|-1>*<matrix|<tformat|<table|<row|<cell|X>>|<row|<cell|Y>>>>>
    </equation*>

    Il sistema nelle nuove coordinate diventa:

    <\equation*>
      <matrix|<tformat|<table|<row|<cell|<wide|X|^>>>|<row|<cell|<wide|Y|^>>>>>>=U<rsup|-1>*<matrix|<tformat|<table|<row|<cell|<wide|X|\<dot\>>>>|<row|<cell|<wide|Y|\<dot\>>>>>>>=U<rsup|-1>*H*<matrix|<tformat|<table|<row|<cell|X>>|<row|<cell|Y>>>>>=U<rsup|-1>**H*U*<matrix|<tformat|<table|<row|<cell|<wide|X|^>>>|<row|<cell|<wide|Y|^>>>>>>=<matrix|<tformat|<table|<row|<cell|\<Lambda\><rsub|s>>|<cell|0>>|<row|<cell|0>|<cell|\<Lambda\><rsub|u>>>>>><matrix|<tformat|<table|<row|<cell|<wide|X|^>>>|<row|<cell|<wide|Y|^>>>>>>
    </equation*>

    Questo è un sistema <with|font-series|bold|lineare e disaccoppiato> per
    <math|<wide|X|^>> e <math|<wide|Y|^>>.

    La soluzione al tempo <math|T> può essere trovata nel seguente modo:

    <\eqnarray*>
      <tformat|<table|<row|<cell|<wide|X|^><around*|(|T|)>=e<rsup|\<Lambda\><rsub|s><around*|(|T-t|)>>*<wide|X|^><around*|(|t|)>>|<cell|\<Longrightarrow\>>|<cell|<wide|X|^><around*|(|t|)>=e<rsup|-\<Lambda\><rsub|s><around*|(|T-t|)>>*<wide|X|^><around*|(|T|)>>>|<row|<cell|<wide|Y|^><around*|(|T|)>=e<rsup|\<Lambda\><rsub|u><around*|(|T-t|)>>*<wide|Y|^><around*|(|t|)>>|<cell|\<Longrightarrow\>>|<cell|<wide|Y|^><around*|(|t|)>=e<rsup|-\<Lambda\><rsub|u><around*|(|T-t|)>>*<wide|Y|^><around*|(|T|)>>>>>
    </eqnarray*>

    Ora imponiamo le condizioni al contorno ottenendo:

    <\equation*>
      <matrix|<tformat|<table|<row|<cell|X<around*|(|T|)>>>|<row|<cell|Y<around*|(|T|)>>>>>>=<matrix|<tformat|<table|<row|<cell|I>>|<row|<cell|M>>>>>=<matrix|<tformat|<table|<row|<cell|U<rsub|11>*<wide|X|^><around*|(|T|)>+U<rsub|12><wide|Y|^><around*|(|T|)>>>|<row|<cell|U<rsub|21>*<wide|X|^><around*|(|T|)>+U<rsub|22><wide|Y|^><around*|(|T|)>>>>>>
    </equation*>

    che si utulizzano per ricavare <math|<wide|Y|^><around*|(|T|)>> in
    funzione di <math|<wide|X|^><around*|(|T|)>>:

    <\equation*>
      M<around*|(|U<rsub|11><wide|X|^><around*|(|T|)>+U<rsub|12>*<wide|Y|^><around*|(|T|)>|)>=U<rsub|21><wide|X|^><around*|(|T|)>+U<rsub|22>*<wide|Y|^><around*|(|T|)>
    </equation*>

    <\equation*>
      \<Rightarrow\><wide|Y|^><around*|(|T|)>=-<around*|(|U<rsub|22>-M*U<rsub|12>|)><rsup|-1>*<around*|(|U<rsub|21>-M*U<rsub|11>|)>*<wide|X|^><around*|(|T|)>=G*<wide|X|^><around*|(|T|)>
    </equation*>

    Dalla relazione <math|<around*|[|X<around*|(|t|)><rsup|T>,Y<around*|(|t|)><rsup|T>|]><rsup|T>=U*<around*|[|<wide|X|^><around*|(|t|)><rsup|T>,<wide|Y|^><around*|(|t|)><rsup|T>|]><rsup|T>>,
    si ottiene:

    <\equation*>
      X<around*|(|t|)>=U<rsub|11><wide|X|^><around*|(|t|)>+U<rsub|12><wide|Y|^><around*|(|t|)>=U<rsub|11>e<rsup|-\<Lambda\><rsub|s><around*|(|T-t|)>><wide|X|^><around*|(|t|)>+U<rsub|12>*e<rsup|-\<Lambda\><rsub|u><around*|(|T-t|)>><wide|Y|^><around*|(|t|)>
    </equation*>

    <\equation*>
      =U<rsub|11>e<rsup|-\<Lambda\><rsub|s><around*|(|T-t|)>><wide|X|^><around*|(|t|)>+U<rsub|12>*e<rsup|-\<Lambda\><rsub|u><around*|(|T-t|)>>*G*<wide|X|^><around*|(|t|)>=
    </equation*>

    <\equation*>
      =<around*|[|U<rsub|11>+U<rsub|12>*e<rsup|-\<Lambda\><rsub|u><around*|(|T-t|)>>*G*e<rsup|\<Lambda\><rsub|s><around*|(|T-t|)>>|]>*e<rsup|-\<Lambda\><rsub|s><around*|(|T-t|)>><wide|X|^><around*|(|t|)>
    </equation*>

    Ripetendo lo stesso ragionamento per <math|<wide|Y|^><around*|(|t|)>>:

    <\equation*>
      Y<around*|(|t|)>=<around*|[|U<rsub|21>+U<rsub|22>*e<rsup|-\<Lambda\><rsub|u><around*|(|T-t|)>>*G*e<rsup|\<Lambda\><rsub|s><around*|(|T-t|)>>|]>*e<rsup|-\<Lambda\><rsub|s><around*|(|T-t|)>><wide|X|^><around*|(|t|)>
    </equation*>

    Avendo ora calcolato esplicitamente <math|X<around*|(|t|)>> e
    <math|Y<around*|(|t|)>>, possiamo ottenere
    <math|P<around*|(|t|)>=Y<around*|(|t|)>*X<around*|(|t|)><rsup|-1>>:

    <\equation*>
      P<around*|(|t|)>=<around*|[|U<rsub|21>+U<rsub|22>*e<rsup|-\<Lambda\><rsub|u><around*|(|T-t|)>>*G*e<rsup|\<Lambda\><rsub|s><around*|(|T-t|)>>|]>*<around*|[|U<rsub|11>+U<rsub|12>*e<rsup|-\<Lambda\><rsub|u><around*|(|T-t|)>>*G*e<rsup|\<Lambda\><rsub|s><around*|(|T-t|)>>|]><rsup|-1>
    </equation*>

    Allora la soluzione della DRE ottenuta clacolando solo autovalore e
    autovettori di H.

    \;
  </answer*>

  \;

  \;
</body>

<\initial>
  <\collection>
    <associate|page-medium|paper>
  </collection>
</initial>

<\references>
  <\collection>
    <associate|auto-1|<tuple|?|1>>
    <associate|auto-10|<tuple|<with|mode|<quote|math>|\<bullet\>>|9>>
    <associate|auto-11|<tuple|<with|mode|<quote|math>|\<bullet\>>|9>>
    <associate|auto-12|<tuple|<with|mode|<quote|math>|\<bullet\>>|10>>
    <associate|auto-13|<tuple|<with|mode|<quote|math>|\<bullet\>>|10>>
    <associate|auto-14|<tuple|<with|mode|<quote|math>|\<bullet\>>|11>>
    <associate|auto-15|<tuple|<with|mode|<quote|math>|\<bullet\>>|12>>
    <associate|auto-16|<tuple|<with|mode|<quote|math>|\<bullet\>>|12>>
    <associate|auto-17|<tuple|<with|mode|<quote|math>|\<bullet\>>|12>>
    <associate|auto-18|<tuple|<with|mode|<quote|math>|\<bullet\>>|13>>
    <associate|auto-2|<tuple|?|2>>
    <associate|auto-3|<tuple|2|3>>
    <associate|auto-4|<tuple|<with|mode|<quote|math>|\<bullet\>>|4>>
    <associate|auto-5|<tuple|<with|mode|<quote|math>|\<bullet\>>|6>>
    <associate|auto-6|<tuple|<with|mode|<quote|math>|\<bullet\>>|7>>
    <associate|auto-7|<tuple|<with|mode|<quote|math>|\<bullet\>>|8>>
    <associate|auto-8|<tuple|<with|mode|<quote|math>|\<bullet\>>|9>>
    <associate|auto-9|<tuple|<with|mode|<quote|math>|\<bullet\>>|9>>
  </collection>
</references>

<\auxiliary>
  <\collection>
    <\associate|toc>
      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|Descrivere
      brevemente l'equazione di Hamilton-Jacaobi Bellman. Dimostrare che HJB
      fornisce condizioni necessarie di ottimalità.>
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-1><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|Discutere
      l'equazione differenziale di Riccati e dimostrare che la soluzione
      <with|mode|<quote|math>|P<around*|(|t|)>> esiste per ogni
      <with|mode|<quote|math>|t\<in\><around*|[|0,T|]>>>
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-2><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|<with|font-series|<quote|bold>|Enunciare
      il teorema di essitenza della soluzione del LQR ad orizzonte infinito.
      Dimostrare inoltre che la sequenza di soluzioni
      <with|mode|<quote|math>|P<rsub|T><around*|(|t|)>> del problema ad
      orizzone finito ha un limite per <with|mode|<quote|math>|T\<rightarrow\>\<infty\>>.>>
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-3><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|<with|font-series|<quote|bold>|Enunciare
      il teorema di esistenza della soluzione del LQR ad orizzonte infinito.
      Dimostrare che il sistema a ciclo chiuso con la soluzione di LQR
      risulta asintoticamente stabile.>> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-4><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|<with|font-series|<quote|bold>|Enunciare
      e dimostrare il Principio di Ottimalità>.>
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-5><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|<with|font-series|<quote|bold>|Discutere
      il problema del Tracking e della reiezione di disturbi noti.>>
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-6><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|Dimostrare
      che l'equazione di Hamilton Jacobi Bellman fornisce condizioni
      sufficienti di ottimalità.> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-7><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|Dare
      definizione di Value Iteration> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-8><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|Dare
      definizione di Policy Improvement> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-9><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|Dare
      definizione di Policy Evaluation> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-10><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|Dare
      definizione di Funzione Valore in un contesto di Reinforcement
      Learning> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-11><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|Dare
      definizione di Funzione Qualità> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-12><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|Discutere
      di MPC e dimostrare la ammissibilità,stabilità.>
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-13><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|<with|font-series|<quote|bold>|Enunciare
      il teorema di essitenza della soluzione del LQR ad orizzonte infinito.
      L'unicità della soluzione stabilizzante di ARE.>>
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-14><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|Principio
      Ottimalità (Programmazione Quadratica)>
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-15><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|Equazione
      di Bellman e Soluzione ricorsia di Bellman>
      <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-16><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|Processo
      Decisionale di Markov Stocastico> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-17><vspace|0.5fn>

      <vspace*|1fn><with|font-series|<quote|bold>|math-font-series|<quote|bold>|Discutere
      l'equazione differenziale di Riccati e dimostrare esistenza soluzione
      tramite matrice Hamiltoniana> <datoms|<macro|x|<repeat|<arg|x>|<with|font-series|medium|<with|font-size|1|<space|0.2fn>.<space|0.2fn>>>>>|<htab|5mm>>
      <no-break><pageref|auto-18><vspace|0.5fn>
    </associate>
  </collection>
</auxiliary>