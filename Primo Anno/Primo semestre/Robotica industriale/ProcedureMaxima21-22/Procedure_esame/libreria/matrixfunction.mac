ratprint: false;
eigenvect(A):=block([res],res:[],sizeM:size(A),sA:lambda*ident(sizeM[1])-A,polA:expand(determinant(sA)),autval:solve(polA = 0,lambda),adjA:adjoint(sA),sizeAut:size(autval),for i thru sizeAut[2] do (adjAaut:subst(autval[i],adjA),autvect:args(columnspace(adjAaut)),sizeAutvect:size(autvect),mg:sizeAutvect[2],print("MolteplicitÃ  geometrica",mg),if mg = 0 then res:ratsimp(expand(eigenvectors(A))) elseif mg # 0 then res:append(res,[[autval[i],autvect[1]]])),res);
R2(theta):=matrix([cos(theta),-sin(theta)],[sin(theta),cos(theta)]);
checkR2(R):=block([res],RRt:trigsimp(R . transpose(R)),if is(equal(trigsimp(RRt),ident(2))) then print("La matrice Ã¨ isometrica"),detR:trigsimp(determinant(R)),if detR = 1 then print("La matrice Ã¨ di rotazione") else (if equal(detR,1) # 1 then return("La matrice non Ã¨ di rotazione")));
R[z](theta):=matrix([cos(theta),-sin(theta),0],[sin(theta),cos(theta),0],[0,0,1]);
Raxis(k,theta):=block([res],if not symbolp(theta) and not subvarp(theta) and (not atom(theta) and nonscalarp(theta)) then return("Insert scalar input") else (if k = x then res:matrix([1,0,0],[0,cos(theta),-sin(theta)],[0,sin(theta),cos(theta)]) elseif k = y then res:matrix([cos(theta),0,sin(theta)],[0,1,0],[-sin(theta),0,cos(theta)]) elseif k = z then res:matrix([cos(theta),-sin(theta),0],[sin(theta),cos(theta),0],[0,0,1]) else res:"Incorrect axis of rotation"));
skewMatrix(v):=block([res],sizeV:size(v),if nonscalarp(v) and sizeV[2] = 1 then (m:sizeV[1],S:zeromatrix(m,m),for i thru m do (for j thru m do if i = j then S[i][j]:0 elseif j > i then (temp:(-1)^(j-i)*v[m-remainder(i+j,m)][1],S[i][j]:temp,S[j][i]:-temp))) else return("Insert column axis or a non scalar input"),res:S);
checkSkew(M):=block([res],sizeV:size(M),if nonscalarp(M) and sizeV[1] = sizeV[2] and sizeV[1] # 1 then (for i thru sizeV[1] do (for j from i thru sizeV[1] do (if i = j and M[i][j] # 0 then res:false elseif i # j and M[i][j] # -M[j][i] then res:false,if res = false then return(res)),if res = false then return(res)),if res = false then return(res),res:true,return(res)) else return("Input non Ã¨ una matrice"));
inverseLaplace(SI):=block([res],M:SI,MC:SI,for i thru 3 do (for j thru 3 do (a:M[i,j],b:ilt(a,s,theta),MC[i,j]:b)),res:MC);
rotLaplace(k):=block([res],S:skewMatrix(k),I:ident(3),res:inverseLaplace(invert(s*I-S)));
checkR3(R):=block([res],RRt:trigsimp(R . transpose(R)),sizeR:size(R),detR:trigsimp(ratsimp(determinant(R))),if sizeR[1] = sizeR[2] then (if trigsimp(RRt)=ident(sizeR[1]) and detR = 1 then return(true)) else return(false));
axes(M):=block([res],columns:transpose(M),res:zeromatrix(3,1),for i thru length(columns) do if columns[i][1] # 0 or columns[i][2] # 0 or columns[i][3] # 0 then return(m:transpose(columns[i])),res:m);
sinRotation(skewMat,RRT2):=block([res],for i thru 3 do (for j thru 3 do (a:skewMat[i][j],if a # 0 then (b:RRT2[i][j],return(value:b/a)))),res:value);
cosRotation(x,y):=block([res],for i thru 3 do (for j thru 3 do (c:x[i][j],if c # 0 then (d:y[i][j],return(t:(c-d)/c)))),res:t);
degree(v,M):=block([sinR,cosR,res],S:skewMatrix(v),I:ident(3),RRsin:trigsimp(((M-transpose(M))*1)/2),RRcos:trigsimp(((M+transpose(M))*1)/2-I),sinR:sinRotation(S,RRsin),SS:S . S,cosR:cosRotation(SS,RRcos),res:atan2(expand(sinR),expand(cosR)));
axesDegree(R):=block([v,theta,res],if checkR3(R) then (I:ident(3),adjR:adjoint(I-R),v:axes(adjR),vNorm:v/sqrt(v . v),theta:degree(vNorm,R),res:[["Axe:",factor(trigreduce(trigsimp(expand(vNorm))))],["Theta=",factor(trigreduce(trigsimp(expand(theta))))]]) else res:"R is not rotation matrix");
degreeVector(x):=block([res],vNorm:x . x,cosTheta:(1-vNorm)/(1+vNorm),sinTheta:(2*sqrt(vNorm))/(1+vNorm),if sinTheta/(1+cosTheta) > 0 then degree:atan2(sinTheta,cosTheta) else degree:atan2(-sinTheta,cosTheta),res:degree);
cayleyRotation(a):=block([res],if nonscalarp(a) and not symbolp(a) and not subvarp(a) then (S:skewMatrix(a),I:ident(3),R:(I+S) . invert(I-S),params:normalize(a,theta),degree:degreeVector(params[1]),degree:subst(degree,theta,params[2]),print("Matrice di rotazione, Matrice antisimmetrica, asse, angolo"),res:[facsum(expand(R)),S,params[1],degree],return(res)) else res:"Check Arguments");
cayleySkewMatrix(R):=block([res],if checkR3(R) then (I:ident(3),S:invert(R+I) . (R-I),v:matrix([S[3][2]],[S[1][3]],[S[2][1]]),params:normalize(v,theta),degree:degreeVector(params[1]),degree:subst(degree,theta,params[2]),print("Matrice di rotazione, Matrice antisimmetrica, asse, angolo"),res:[R,S,params[1],degree],return(res)) else res:"Matrix is not rotation");
rodriguez(y):=block([res],y:rat(bfloat(y)),print(y),val:normalize(y,theta),print(val),I:ident(3),S:skewMatrix(val[1]),res:I+S.S*(1-cos(val[2]))+S*sin(val[2]));