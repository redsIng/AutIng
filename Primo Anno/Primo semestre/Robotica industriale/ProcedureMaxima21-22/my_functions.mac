
exportfun():=stringout("C:/Users/loryb/Desktop/Magistrale-Tor-Vergata/Primo Anno/Primo semestre/Robotica industriale/ProcedureMaxima21-22/my_functions.mac",functions);
size(a):=block(if nonscalarp(a) then (row:length(a),col:length(transpose(a)),return([row,col])) else return([1,1]));
rational(a):=block([res],res:gfactor(ratexpand(radcan(expand(a)))),return(res));
vect(a,b):=block([res],a:rational(a),b:rational(b),[xA,yA]:size(a),[xB,yB]:size(b),if xA = 3 and yA = 1 and xB = 3 and yA = 1 and nonscalarp(a) and nonscalarp(b) then (mProd:matrix([e[x],e[y],e[z]],[a[1][1],a[2][1],a[3][1]],[b[1][1],b[2][1],b[3][1]]),detM:radcan(expand(determinant(mProd))),if detM = 0 then detM:zerofor(a),ex:matrix([1],[0],[0]),ey:matrix([0],[1],[0]),ez:matrix([0],[0],[1]),res:psubst([e[x] = ex,e[y] = ey,e[z] = ez],detM)) else res:"Incorrect vectors dimension");
checkR(R):=block([res],[xR,yR]:size(R),if nonscalarp(R) and xR = yR and not symbolp(R) and not subvarp(R) then (R:rational(R),RRt:factor(expand(trigreduce(expand(R . transpose(R))))),detR:factor(expand(trigreduce(expand(determinant(R))))),if is(equal(trigsimp(RRt),ident(xR))) and detR = 1 then return(true)) else return(false));
R(theta):=matrix([cos(theta),-sin(theta)],[sin(theta),cos(theta)]);
Raxis(k,theta):=block([res],if not symbolp(theta) and not subvarp(theta) and nonscalarp(theta) then return("Insert scalar input") else (theta:rational(theta),if not symbolp(theta) and not subvarp(theta) then (if not numperp(theta) then (part:partition(theta,%pi),pi:%pi,if not member(pi,part) then theta:rational(theta))),if k = x then res:matrix([1,0,0],[0,cos(theta),-sin(theta)],[0,sin(theta),cos(theta)]) elseif k = y then res:matrix([cos(theta),0,sin(theta)],[0,1,0],[-sin(theta),0,cos(theta)]) elseif k = z then res:matrix([cos(theta),-sin(theta),0],[sin(theta),cos(theta),0],[0,0,1]) else res:"Incorrect axis of rotation"));
skewMatrix(v):=block([res],sizeV:size(v),if nonscalarp(v) and sizeV[2] = 1 and sizeV[1] > 2 then (m:sizeV[1],S:zeromatrix(m,m),for i thru m do (for j thru m do if i = j then S[i][j]:0 elseif j > i then (temp:(-1)^(j-i)*v[m-remainder(i+j,m)][1],S[i][j]:temp,S[j][i]:-temp))) else return("Insert column axis or a non scalar input"),res:S);
checkSkew(M):=block([res],sizeV:size(M),if nonscalarp(M) and sizeV[1] = sizeV[2] and sizeV[1] # 1 then (for i thru sizeV[1] do (for j from i thru sizeV[1] do (if i = j and M[i][j] # 0 then res:false elseif i # j and M[i][j] # -M[j][i] then res:false,if res = false then return(res)),if res = false then return(res)),if res = false then return(res),res:true,return(res)) else return("Input non Ã¨ una matrice"));
Reulero(a,b,c,theta):=block([res],axes:[x,y,z],if member(a,axes) and member(b,axes) and member(c,axes) and a = c and (symbolp(theta) or subvarp(theta)) then (firstConfig:Raxis(a,%pi/2) . Raxis(b,theta) . Raxis(c,(-%pi)/2),secondConfig:Raxis(a,(-%pi)/2) . Raxis(b,-theta) . Raxis(c,%pi/2),res:[firstConfig,secondConfig]) else (print("Check Arguments"),return([])));
checkEulero(list):=block([res],res:[],for i thru 6 do (Rfinal:Raxis(list[i][1],theta),[Reul,Reul2]:Reulero(list[i][2],list[i][3],list[i][4],theta),if Rfinal-Reul = zeromatrix(3,3) then res:append(res,[[list[i][1],list[i][2],list[i][3],list[i][4],"+"]]) elseif Rfinal-Reul2 = zeromatrix(3,3) then res:append(res,[[list[i][1],list[i][2],list[i][3],list[i][4],"-"]])),return(res));
inverseLaplace(SI,norma):=block([res],M:SI,MC:SI,for i thru 3 do (for j thru 3 do (a:M[i,j],b:ilt(a,s,theta*norma),MC[i,j]:b)),res:MC);
rotLaplace(k):=block([res,M,MC,SI,I,S],[row,col]:size(k),if nonscalarp(k) and col = 1 then (norm:sqrt(transpose(k) . k),S:skewMatrix(k/norm)/norm,I:ident(row),res:trigreduce(expand(inverseLaplace(invert(s*I-S),norm))),return(rational(res))) else return([]));
normalize(vect):=block([res],norm:sqrt(transpose(vect) . vect),vect:vect/norm,res:[vect,norm],return(res));
rodriguez(y):=block([res],vect:normalize(y),I:ident(3),S:skewMatrix(vect[1]),res:I+S . S*(1-cos(vect[2]*theta))+S*sin(vect[2]*theta),return(res));
eigenvect(A):=block([res],res:[],A:rational(A),[x,y]:size(A),if x = y and nonscalarp(A) then (sizeM:size(A),sA:lambda*ident(x)-A,polA:rational(expand(determinant(sA))),autval:solve(polA = 0,lambda),adjA:adjoint(sA),[sizeAutx,sizeAuty]:size(autval),for i thru sizeAuty do (adjAaut:subst(autval[i],adjA),autvect:args(columnspace(adjAaut)),[sizeAutvectx,sizeAutvecty]:size(autvect),mg:sizeAutvecty,if mg = 0 then res:append(res,[[autval[i],args(nullspace(subst(autval[i],sA)))]]) elseif mg # 0 then res:append(res,[[autval[i],autvect[1]]]))) else print("Insert a Matrix"),return(rootscontract(ratsimp(radcan(expand(res))))));
RR(theta):=rodriguez(ratsimp(v));
sinRotation(skewMat,RRT2):=block([res],for i thru 3 do (for j thru 3 do (a:skewMat[i][j],if a # 0 then (b:RRT2[i][j],value:expand(b/a),return(value)))),return(value));
cosRotation(x,y):=block([res],for i thru 3 do (for j thru 3 do (c:x[i][j],if c # 0 then (d:y[i][j],t:expand((c-d)/c),return(t)))),return(t));
degree(v,M):=block([sinR,cosR,res],S:skewMatrix(v),I:ident(3),RRsin:trigsimp(((M-transpose(M))*1)/2),RRcos:trigsimp(((M+transpose(M))*1)/2-I),sinR:sinRotation(S,RRsin),SS:trigsimp(trigexpand(S . S)),cosR:cosRotation(SS,RRcos),res:atan2(sinR,cosR),return(res));
axesDegree(R):=block([v,theta,res],dimR:size(R),R:rational(R),if checkR(R) then (eigenVectors:rootscontract(trigsimp(expand(eigenvect(R)))),dimV:size(eigenVectors),v:zeromatrix(dimR[1],1),for i thru dimV[2] do if args(eigenVectors[i][1])[2] = 1 then v:rootscontract(radcan(trigsimp(expand(eigenVectors[i][2])))),if v = zeromatrix(dimR[1],1) then return([]),vNorm:rootscontract(radcan(trigsimp(trigexpand(normalize(v))))),deg:degree(vNorm[1],R),res:[["Axe:",factor(trigreduce(trigsimp(expand(vNorm[1]))))],["Theta:",factor(trigreduce(trigsimp(expand(deg))))]],return(res)) else res:"R is not rotation matrix");
